#!/usr/bin/env python3

import queue
import time as t
import numpy as np
import rospy
import cv_bridge
import cv_resize
from sensor_msgs.msg import Image

def on_image(msg):
    with on_image.queue.mutex:
        on_image.queue.queue.clear()
    on_image.queue.put(msg)

on_image.queue = queue.Queue()

if __name__ == "__main__":
    rospy.init_node('segmentation_node')

    MODEL = rospy.get_param('~model', 'mnv2_bdd100k_driveable_513')
    TOPIC_IMAGE = rospy.get_param('~topic_image', 'image_raw')
    TOPIC_SEMANTIC = rospy.get_param('~topic_semantic', 'semantic')
    TOPIC_SEMANTIC_COLOR = rospy.get_param('~topic_semantic_color', 'semantic_color')
    SCALE = rospy.get_param('~scale', 1.0)
    RATE = rospy.get_param('~rate', 30.0)

    sub_image = rospy.Subscriber(TOPIC_IMAGE, Image, on_image)
    pub_semantic = rospy.Publisher(TOPIC_SEMANTIC, Image, queue_size = 1)
    pub_semantic_color = rospy.Publisher(TOPIC_SEMANTIC_COLOR, Image, queue_size = 1)

    rate = rospy.Rate(RATE)

    model = getattr(__import__('models', globals(), locals(), fromlist = [MODEL]), MODEL).Model()
    rospy.set_param("semantic_categories", model.categories)

    def down_scale(cv_image):
        if SCALE == 1.0:
            return cv_image

        h, w = cv_image.shape[:2]
        h = int(h * SCALE)
        w = int(w * SCALE)
        return cv_resize.resize(cv_image, (w, h))

    def up_scale(cv_image):
        if SCALE == 1.0:
            return cv_image

        h, w = cv_image.shape[:2]
        h = int(h / SCALE)
        w = int(w / SCALE)
        return cv_resize.resize(cv_image, (w, h))


    while not rospy.is_shutdown():
        rate.sleep()

        next_image_message = None

        try:
            next_image_message = on_image.queue.get(block=False)
        except queue.Empty as empty:
            pass

        if next_image_message is None:
            continue

        s = t.time()

        header = next_image_message.header
        cv_image = cv_bridge.imgmsg_to_cv2(next_image_message)
        cv_image = down_scale(cv_image)

        semantic = model.infer([cv_image])[0]

        if pub_semantic.get_num_connections() > 0:
            output_image = semantic.astype(np.uint8)
            output_image = up_scale(output_image)
            m = cv_bridge.cv2_to_imgmsg(output_image, encoding = 'mono8')
            m.header.stamp.secs = header.stamp.secs
            m.header.stamp.nsecs = header.stamp.nsecs
            pub_semantic.publish(m)

        if pub_semantic_color.get_num_connections() > 0:
            output_image = model.color_map[semantic.astype(np.uint8)]
            output_image = up_scale(output_image)
            m = cv_bridge.cv2_to_imgmsg(output_image, encoding = 'rgb8')
            m.header.stamp.secs = header.stamp.secs
            m.header.stamp.nsecs = header.stamp.nsecs
            pub_semantic_color.publish(m)

        rospy.loginfo("inference time: {}".format(t.time() - s))